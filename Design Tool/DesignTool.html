<!--This code is developed by Hakim MABED hmabed@gmail.com-->
<!--14/04/2019                -->
<!--Only for educational and personal use-->
<!--Objective: Provide a tool for radio network engineering, training and testing-->


<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
	<meta charset="utf-8">

	<title>Mobile Network Optimization Tool</title>     
	<link rel="shortcut icon" type="image/x-icon" href="icon.ico">

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css"
	integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
	crossorigin=""/>
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
	<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
	<script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"
	integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg=="
	crossorigin=""></script>
	<script src="https://npmcdn.com/leaflet-geometryutil"></script>
	<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
	<style>
		<style>
		html, body, #map-canvas {
		height: 100%;
		margin: 0px;
		padding: 0px
		}
		</style>
	<style type="text/css">
		body
		{
		   background-color: #FFFFFF;
		   color: #000000;
		   font-family: Arial;
		   font-size: 13px;
		   margin: 0;
		   padding: 0;
		}
	</style>

	<style type="text/css">
		#conteneur {width:100%; margin:0 auto;background-color: #C7C7C7;}
		#header {background-color: #FFD700;width:100%;}
		#footer {background-color: #FFD700;width:100%;}
		#sidebar {position:absolute;background-color: #C7C7C7;width:230px;}
		#contenu {margin-left:230px;}
		#mapid { height: 800px; }

		#Combobox1
		{
		   border: 1px #A9A9A9 solid;
		   background-color: #FFFFFF;
		   color: #000000;
		   font-family: Arial;
		   font-size: 13px;
		}

		#message
		{
		   border: 0px #A9A9A9 solid;
		   background-color: #FFD700;
		   font-family: Arial;
		   font-size: 13px;
		}
	</style>

	<script src="jquery.min.js"></script>
	<script>

	//Input Data
	//The deployment area is subdivided into blocks, each block is subdivided into bins (geographical points)
	var blockWidth =10; //Number of column blocks
	var blockHeight =10; //Number of line blocks
	var bl=0;   	//counter of block line (during scanning)
	var bc=0;		//counter of block column (during scanning)
	var southCorner;//the south-East point of the deployment area
	var bloc;		//current scanned block 
	var lngBloc; 	//Lng width of a block 
	var latBloc;	//Lat height of a block 
	var pdm=20;		//Number of bins if a block = pdm x pdm
	var latBin; 	//Lat size of a bin (about 10metres)
	var lngBin;		//Lng size a bin (about 10metres)
	
	var size;
	var xx,yy;
	var chaine="";
	
	var elevations;
	var relief = [];    	//elevation of the natural landscape 
	var architecture = [];	//elevation of the buildings 
	var elevation=[];		//the total elevation of natural landscape and buildings
	
	var frequencySpectrum,qualityThreshold;  // radio interface characteristics : quality threshold and frequency band
	var antenne;
	var CCost=0;
	var carto=false;
	var a;
	var angleindex;

	var firstpropag=true //the relief table should be normalized at the beginning
	function AntennaConstructor(location, omni, tilt, azimut, pow)
	{
		this.location=location; //position of the antenna
		this.omni=omni;			//omni or not
		this.azimut=azimut;		//azimuth in radian
		this.power=pow;		//power in Db
		this.tilt=tilt;			//tilt in radian
	}
	var antennas=[];     	//set of antennas
	var nbantennas=0;     	//number of antennas
	var bins=[];			
	var blocs=[];
	var axes = [];  //set of roads - not yet implemented
	var largaxes=[];	//width of the roads
	var isOnTheRoad=[];   
	var orientation=[];   //sens of circulation

	var power=[];      //power received of each bin (x,y) from an antenna (z) = power[z][x][y]
	//directional antenna radiation pattern
	var VertRadiationPattern = [
	0, -4, -8, -12, -15, -17, -18, -19, -20, -23, -26, -28, -30, -31, -31, -30, -27, -23, -18, -23, -27, -31, -33, -34, -33, -31, -29, -26, -23, -20, -18, -19, -20, -19, -19, -18, -18, -18, -19, -19, -20, -19, -18, -20, -23, -26, -29, -31, -33, -34, -33, -31, -27, -23, -18, -23, -27, -30, -31, -31, -30, -28, -26, -23, -20, -19, -18, -17, -15, -12, -8, -4, 0
	];
	var HorzRadiationPattern = [
	0, -4, -8, -12, -15, -17, -18, -19, -20, -23, -26, -28, -30, -31, -31, -30, -27, -23, -18, -23, -27, -31, -33, -34, -33, -31, -29, -26, -23, -20, -18, -19, -20, -19, -19, -18, -18, -18, -19, -19, -20, -19, -18, -20, -23, -26, -29, -31, -33, -34, -33, -31, -27, -23, -18, -23, -27, -30, -31, -31, -30, -28, -26, -23, -20, -19, -18, -17, -15, -12, -8, -4, 0
	];
	var group1 = L.featureGroup();
	var modeclick=0; // = 4 = placer un UE
	
	//local variables
	var omni;
	var i,j;
	var cst1;
	var cst2;
	var hpoint;
	var delta;
	var alpha;
	var angle,ti,az;
	var p1,p2;
	var idist, jdist;
	var jpas; 			
	var ipas;
	var sobstacle;
	var s;
	var iobstacle;			
	var jobstacle;
	var hmax;	
	var dobs;
	var hvmax;
	var hant;
	var point;
	var d1;
	var d2;
	var R1;
	var v;
	var LKE;
	var LFS;
	var L;
	var bin = [];	

	var ant;
	var circle;
 	var colors=[];
	var start;

	var ueStart, ueArrival;
	var markerUeStart, markerUeArrival;
	var uePosition; // User Equipment current position (while moving)
	var uePathRegistered = []; // should be the gps path.. :(
	var selectedAntennaCircle;  // marker corresponding to the paired antenna
	var routingMap; // gps object that generate the request 
	var markerIcon; // pedestrian gif
	var toggle = 0; // correspond to the running state of the simu (0 = not running 1 = running)
	var intervalID; // waitong time before sleeping between two ticks
	var coefPathA, coefPathB // path coefficient for the UE to go to one point to another

	//action after the selection of the south-east corner of the covering area
	function placeCorner(location) {
		southCorner=location;
		bloc=location;
		var p3=L.latLng(bloc.lat+0.001, bloc.lng);
		var distance=L.GeometryUtil.length([location, p3]);

		latBin=0.001*10/distance;
		
		p3=L.latLng(bloc.lat, bloc.lng+0.001);
		var distance=L.GeometryUtil.length([location, p3]);
		lngBin=0.001*10/distance;
		
		lngBloc=lngBin*pdm; //size of a block  (in longitude)
		latBloc=latBin*pdm;	//the same for the latitude

		document.getElementById('message').value = "Scan in progress !!!";
		blockWidth =parseInt(document.getElementById('blockWidth ').value);
		blockHeight =parseInt(document.getElementById('blockHeight ').value);
		document.getElementById('blockWidth ').disabled='disabled';
		document.getElementById('blockHeight ').disabled='disabled';
		for(i=0;i<pdm*blockHeight ;i++){
			relief.push([]);
			for(j=0;j<blockWidth *pdm;j++) relief[i].push(0);
		}
		for(i=0;i<pdm*blockHeight ;i++){
			elevation.push([]);
			for(j=0;j<blockWidth *pdm;j++) elevation[i].push(0);
		}
		for(i=0;i<pdm*blockHeight ;i++){
			architecture.push([]);
			for(j=0;j<blockWidth *pdm;j++) architecture[i].push(0);
		}
		
		for(i=0;i<pdm*blockHeight ;i++){
			isOnTheRoad.push([]);
			for(j=0;j<blockWidth *pdm;j++) {isOnTheRoad[i].push([]);isOnTheRoad[i][j]=false;}
		}
		orientation=[];
		for(i=0;i<pdm*blockHeight ;i++){
			orientation.push([]);
			for(j=0;j<blockWidth *pdm;j++){
				orientation[i].push([]);
				orientation[i][j]=-1;
			}
		}
		
		drawPath();
	}
	function activate(){
	   document.getElementById('btn').disabled = '';
	}
	var addantenna;
	var line;
	
		
	function drawPath() {

		mymap.addLayer(group1);

		//generation of random relief : waiting for leaflet API to get real data 
		for(line=0;line<pdm;line++) //for each line in the current block
		{
			for(col=0;col<pdm;col++) //for each column in the current block
			{
				if(col==0 && line==0)
					relief[bl*pdm+line][bc*pdm+col]=Math.floor(Math.random()*10);
				else if(col==0)
					relief[bl*pdm+line][bc*pdm+col]=Math.abs(relief[bl*pdm+line-1][bc*pdm+col]+Math.floor(Math.random()*3)-1);
				else if(line==0)
					relief[bl*pdm+line][bc*pdm+col]=Math.abs(relief[bl*pdm+line][bc*pdm+col-1]+Math.floor(Math.random()*3)-1);
				else relief[bl*pdm+line][bc*pdm+col]=Math.abs((relief[bl*pdm+line-1][bc*pdm+col]+relief[bl*pdm+line-1][bc*pdm+col])/2+Math.floor(Math.random()*3)-1);
			}
		}
		//display the scanned block
		var zonecontour = L.polygon([
			[bloc.lat, bloc.lng],
			[bloc.lat+latBin*pdm, bloc.lng],
			[bloc.lat+latBin*pdm, bloc.lng+lngBloc],
			[bloc.lat, bloc.lng+lngBloc]
		]).addTo(group1);


		bc++;
		if(bc==blockWidth ){  
			bc=0;
			bl++;
			bloc=L.latLng(bloc.lat+latBin*pdm, southCorner.lng);
		}
		else{
			bloc=L.latLng(bloc.lat, bloc.lng+lngBloc);
		}
		//End of deployment area scanning
		if(bl==blockHeight ) {
			document.getElementById('propag').disabled = '';
			document.getElementById('routes').disabled = '';
			document.getElementById('completer').disabled = '';
			document.getElementById('axes').disabled = '';
			document.getElementById('antenne').disabled = '';
			document.getElementById('batiment').disabled = '';
			document.getElementById('saveBat').disabled = '';
			document.getElementById('loadBat').disabled = '';
			document.getElementById('ecole').disabled = '';
			document.getElementById('ue').disabled = '';
			document.getElementById('startSim').disabled = '';

			mymap.removeLayer(group1);
			// Display the deployment area	
			var zonecontour = L.polygon([
				[southCorner.lat, southCorner.lng],
				[southCorner.lat+latBloc*blockHeight , southCorner.lng],
				[southCorner.lat+latBloc*blockHeight , southCorner.lng+lngBloc*blockWidth ],
				[southCorner.lat, southCorner.lng+lngBloc*blockWidth ]
			]).addTo(mymap);

			document.getElementById('message').value = "Choisissez une action !";

			return;
		}
		//scan the next block
		setTimeout("drawPath()",10);
	}

	var markerantenna=[];
	function placeAntennaConstructor(location,pow,type,tilt,azimut) {
		antenne=new AntennaConstructor(location,true);

		//if the antenna is added by a mousse click
		if( typeof(type) == 'undefined' ){
			if(document.getElementById('omni').checked)
				omni = true;
			else omni=false;
			antenne.omni=omni;
			antenne.tilt = document.getElementById('tilt').value;
			if (antenne.tilt != null) {
					tilt=parseInt(antenne.tilt)*Math.PI/180;
					antenne.tilt=tilt;
				}
			else antenne.tilt=0;
			if(!omni){
				var az = document.getElementById('azimut').value;
				if (az != null) {
					azimut=parseInt(az)*Math.PI/180;
					antenne.azimut=azimut;
				}
				else antenne.azimut=0;
			}
			objpower=document.getElementById('power');
			antenne.power = parseInt(objpower.value);
		}
		//it is a restored antenna from stored data 
		else {
			if(type=="omni"){
				omni=true;
				antenne.omni=omni;
				antenne.azimut=-1;
				antenne.tilt=tilt;
				antenne.power=pow;
			}
			else{
				omni=false;
				antenne.omni=omni;
				antenne.azimut=azimut;
				antenne.tilt=tilt;
				antenne.power=pow;
			}
		}
		//display the antenna 
		//circle if it is an omni antenna
		if(	omni==true){
			var circle=L.circle([location.lat, location.lng], {
				color: 'red',
				fillColor: '#f03',
				fillOpacity: 0.5,
				radius: 10
				}).addTo(mymap);
			// Add the circle to the map.
			markerantenna.push(circle);
		}
		//a line if it is a directional antenna
		else{
			var arrow = L.polyline([
				location,
				L.latLng(location.lat+2*latBin*Math.sin(Math.PI/2-azimut), location.lng+2*lngBin*Math.cos(Math.PI/2-azimut))
			],{weight: 1,color: 'red'}).addTo(mymap);
			var arrow = L.circle([location.lat, location.lng],{
				color : 'red',
				fillColor: '#f03',
				fillOpacity: 1,
				radius: 2}).addTo(mymap);
		}
		antennas.push(antenne);
		nbantennas++;
		document.getElementById('message').value = "Choisissez une action !";
		frameantenna.style.visibility='none';
	}

	function placeUE(location){
		console.log("Placing Starting point");
		console.log("Location : " + location);
		ueStart = {location};
		uePosition = location;
		modeclick = 5;
		markerUeStart = L.marker([ueStart.location.lat,ueStart.location.lng]).addTo(mymap);		

	}

	function placeArrival(location){
		console.log("Placing Arrival point");
		console.log("Location : " + location);
		modeclick = null;
		ueArrival = location;
		markerUeArrival = L.marker(ueArrival).addTo(mymap);

		coefPathA = (ueArrival.lat - ueStart.location.lat) / (ueArrival.lng - ueStart.location.lng);
		coefPathB = ueStart.location.lat - coefPathA * ueStart.location.lng;

		// sortAntennasUE(uePosition);
		// set3ClosestAntennas(uePosition);
		// setUEAntenna(uePosition);
		// setUE(uePosition);
		console.log(ueStart);
		console.log(ueArrival);

		// if(routingMap != undefined)
		// 	mymap.removeLayer(routingMap);
		// routingMap = L.Routing.control({
		//   waypoints: [
		//     uePosition,
		//     ueArrival
		//   ],
		//   show: false
		// }).addTo(mymap);




		// var tab = [];
		// for(dis in this.routingMap._plan._map._layers)
		// 	tab.push( this.routingMap._plan._map._layers[dis]._latlng);
			// console.log("latlng : " + this.routingMap._plan._map._layers[dis]._latlng);

		// this.routingMap._plan._map._layers[260]._latlng
		// var plan = routingMap.getPlan();
		// console.log("leaflet-interactive");
	}

	//action when the radio propagation computing is required : click on the button
	function propagation() {
		//avoid re-click on the button during the computation
		document.getElementById('propag').disable='disabled';
		//normalize the elevation data
		if(firstpropag==true)
		{
			firstpropag=false;
			min=10000;
			for(i=0;i<pdm*blockHeight ;i++)
				for(j=0;j<blockWidth *pdm;j++) 
					if(relief[i][j]<min) min=relief[i][j];			
			for(i=0;i<pdm*blockHeight ;i++)
				for(j=0;j<blockWidth *pdm;j++) 
					relief[i][j]=relief[i][j]-min;
		}
		for(i=0;i<pdm*blockHeight ;i++){
			for(j=0;j<blockWidth *pdm;j++){
				elevation[i][j]=relief[i][j]+architecture[i][j];
			}
		}
		power=[];
		for(a=0;a<nbantennas;a++){
			power.push([]);
			for(i=0;i<pdm*blockHeight ;i++){
				power[a].push([]);
				for(j=0;j<blockWidth *pdm;j++){
					power[a][i].push([]);
					power[a][i][j]=-1000;
				}
			}
		}
		rep=document.getElementById('methode').value;
		if(document.getElementById('methode').value=="1") propagationSKE();
		else if(document.getElementById('methode').value=="2") propagationBull();
		else if(document.getElementById('methode').value=="8") propagationCostHata();
		else if(document.getElementById('methode').value=="9") propagationWalfisch();
		else if(document.getElementById('methode').value=="11") propagationFreeSpace();
		document.getElementById('cartepower').disabled='';
		document.getElementById('carteinterference').disabled='';
		document.getElementById('cartehandover').disabled='';
		document.getElementById('cartecellule').disabled='';
		document.getElementById('carteresidence').disabled='';
		document.getElementById('propag').disable='';
	}

	function GetColor(p) {
		
		/*index=parseInt((50-p)*520/(50-qualityThreshold));
		r=colors[index][0];
		v=colors[index][1];
		b=colors[index][2];*/
		if(p>0) {
			r=251;v=0;b=0;
		}
		else if(p>-50) {r=250;v=123;b=0;}
		else if(p>-70) {r=251;v=220;b=0;}
		else if(p>-80) {r=244;v=251;b=0;}
		else if(p>-90) {r=188;v=251;b=0;}
		else if(p>-100) {r=1;v=250;b=57;}
		else if(p>-105) {r=0;v=251;b=201;}
		else if(p>-110) {r=0;v=207;b=251;}
		else if(p>-115) {r=1;v=69;b=250;}
		else {r=51;v=1;b=250;}
		
		if(r<16)strred="0"+r.toString(16); else strred=r.toString(16);
		if(b<16)strblue="0"+b.toString(16); else strblue=b.toString(16);
		if(v<16)strgreen="0"+v.toString(16); else strgreen=v.toString(16);
		return "#"+strred+strgreen+strblue;
	}
	
	
	function propagationCostHata(){
		var p1= L.latLng(bloc.lat, bloc.lng);
		var p2= L.latLng(bloc.lat+latBloc, bloc.lng);
		var hautBin=L.GeometryUtil.length([p1, p2])/pdm;
		p1= L.latLng(bloc.lat, bloc.lng);
		p2= L.latLng(bloc.lat, bloc.lng+lngBloc);
		var largBin=L.GeometryUtil.length([p1, p2])/pdm;
		
		qualityThreshold=parseInt(document.getElementById('qualityThreshold').value);
		frequencySpectrum=parseInt(document.getElementById('frequencySpectrum').value);
		cst1=1.56*Math.log10(frequencySpectrum)+0.8;
		cst2=46.3 + 33.9*Math.log10(frequencySpectrum);
		
		for(a=0;a<nbantennas;a++){
			antennaLocation=antennas[a].location;
			point=L.latLng(antennaLocation.lat,antennaLocation.lng);
			tilt=antennas[a].tilt;
			tilt=180*tilt/Math.PI;
			if(antennas[a].omni==false){
				azimut=antennas[a].azimut;
				azimut=180*azimut/Math.PI;
			}
			iant=Math.floor((antennaLocation.lat-southCorner.lat)/latBin);
			jant=Math.floor((antennaLocation.lng-southCorner.lng)/lngBin);
			hant=elevation[iant][jant]+10;
			if(-200<-iant) iinf=-iant;else iinf=-200;
			if(-200<-jant) jinf=-jant;else jinf=-200;
			if(200>pdm*blockHeight -iant) isup=pdm*blockHeight -iant;else isup=200;
			if(200>pdm*blockWidth -jant) jsup=pdm*blockWidth -jant;else jsup=200;
			
			for(jdist=jinf;jdist<=jsup;jdist++)
			for(idist=iinf;idist<=isup;idist++)
			{
				ipoint=iant+idist;					//coordonnées en maille d'un point de reception	
				jpoint=jant+jdist;	
				if(ipoint<0 || jpoint<0 || ipoint >= pdm*blockHeight  || jpoint>=pdm*blockWidth ) continue;
				point.lat=antennaLocation.lat+idist*latBin
				point.lng=antennaLocation.lng+jdist*lngBin;
				d=L.GeometryUtil.length([antennaLocation, point]);
				if(idist==0 && jdist==0) { 	//si c'est la position de l'antenne alors ignorer
					Loss=0;
				}
				else{
					
					hpoint=elevation[ipoint][jpoint]+1.5;
					if(CCost==3) ahr=3.2*(Math.log10(11.75*hpoint))*(Math.log10(11.75*hpoint))-4.97;
					else ahr=(1.1*Math.log10(frequencySpectrum)-0.7)*hpoint-cst1;
					
					Loss=cst2-13.82*Math.log10(hant); 
					Loss=Loss-ahr+(44.9-6.55*Math.log10(hant))*Math.log10(d/1000.0)+CCost;
					
					angle=180*Math.atan(Math.abs(hant-hpoint)/d)/Math.PI;
					
					angle=Math.abs(tilt-angle);
					
					angleindex=Math.floor(angle/5);
					Loss=Loss+ CCost-VertRadiationPattern[angleindex];
					
					if(antennas[a].omni==false){
						if(idist==0 && jdist>0) angle=90;
						else if(idist==0 && jdist<0) angle=270;
						else {
							angle=180*Math.atan(jdist/idist)/Math.PI;
							if(idist<0)
								angle=angle+180;
							if(angle<0) angle=angle+360;
						}
						angle=Math.abs(angle-azimut);
						angleindex=Math.floor(angle/5);
						Loss=Loss-HorzRadiationPattern[angleindex];
					}
				}
				power[a][ipoint][jpoint]=antennas[a].power-Loss;
			}
		}
		document.getElementById('cartepower').enabled='';
	}
	function propagationSKE() {
		var p1= L.latLng(bloc.lat, bloc.lng);
		var p2= L.latLng(bloc.lat+latBloc, bloc.lng);
		var hautBin=L.GeometryUtil.length([p1, p2])/pdm;
		p1= L.latLng(bloc.lat, bloc.lng);
		p2= L.latLng(bloc.lat, bloc.lng+lngBloc);
		var largBin=L.GeometryUtil.length([p1, p2])/pdm;
		
		for(a=0;a<nbantennas;a++){
			antennaLocation=antennas[a].location;
			point=L.latLng(antennaLocation.lat, antennaLocation.lng);
			iant=Math.floor((antennaLocation.lat-southCorner.lat)/latBin);
			jant=Math.floor((antennaLocation.lng-southCorner.lng)/lngBin);
			hant=elevation[iant][jant]+10;
			qualityThreshold=parseInt(document.getElementById('qualityThreshold').value);
			frequencySpectrum=parseInt(document.getElementById('frequencySpectrum').value);
			tilt=antennas[a].tilt;
			tilt=180*tilt/Math.PI;
			if(antennas[a].omni==false){
				azimut=antennas[a].azimut;
				azimut=180*azimut/Math.PI;
			}
			if(-200<-iant) iinf=-iant;else iinf=-200;
			if(-200<-jant) jinf=-jant;else jinf=-200;
			if(200>pdm*blockHeight -iant) isup=pdm*blockHeight -iant;else isup=200;
			if(200>pdm*blockWidth -jant) jsup=pdm*blockWidth -jant;else jsup=200;
			for(var jdist=jinf;jdist<=jsup;jdist++)
			for(var idist=iinf;idist<=isup;idist++)
			{
				ipoint=iant+idist;					//coordonnées en maille d'un point de reception	
				jpoint=jant+jdist;	
				if(ipoint<0 || jpoint<0 || ipoint >= pdm*blockHeight  || jpoint>=pdm*blockWidth ) continue;
				point.lat=antennaLocation.lat+idist*latBin
				point.lng=antennaLocation.lng+jdist*lngBin;
				d=L.GeometryUtil.length([antennaLocation, point]);
				if(idist==0 && jdist==0) { 	//si c'est la position de l'antenne alors ignorer
					Loss=32.4+20*Math.log10((Math.sqrt(largBin*largBin+hautBin*hautBin)/2)/frequencySpectrum)+20*Math.log10(frequencySpectrum);
				}
				else{
					
					hpoint=elevation[ipoint][jpoint];
					delta=hant-hpoint-1.5;
					
					alpha;							//l'angle fait entre l'antenne, les latitudes et le point de reception
					if(jdist!=0) {
						alpha=Math.atan(idist/(jdist));
						if(idist<0 && jdist<0)  alpha=alpha+3.14;
						else if(idist>=0 && jdist<0) alpha=alpha+3.14;
					}
					else {
						if(idist>0) alpha=1.5707;
						else alpha=-1.5707;
					}
					
					
					jpas=Math.cos(alpha); 			//pas d'avance sur la line directe entre l'antenne et le point de reception
					ipas=Math.sin(alpha);
					distPasBin=Math.sqrt(ipas*ipas*hautBin*hautBin+jpas*jpas*largBin*largBin);
					iobstacle=Math.floor(iant+ipas);	//premier obstacle		
					jobstacle=Math.floor(jant+jpas);
					
					hmax=elevation[iobstacle][jobstacle];	//hauteur du 1er obstacle
					dobs=distPasBin;
					hvmax=hant-(dobs/d)*delta;
					sobstacle=1;
					for(s=1;Math.abs(s*ipas)<Math.abs(idist);s++){	//parcours des obstacle avec un pas ipas, jpas
						dobs=s*distPasBin;
						hv=hant-(dobs/d)*delta;
					
						if(elevation[Math.floor(iant+s*ipas)][Math.floor(jant+s*jpas)]-hv>hmax-hvmax){ 			//si c'est l'obstacle le plus haut 
							hmax=elevation[Math.floor(iant+s*ipas)][Math.floor(jant+s*jpas)];	//alors le stocker
							hvmax=hv;
							iobstacle=Math.floor(iant+s*ipas);
							jobstacle=Math.floor(jant+s*jpas);
							sobstcale=s;
						}
					}
					
					
					LKE=0.0;
					hmax=hmax-hvmax;
					
					if(hmax>0){
						obstacle=L.latLng(antennaLocation.lat+sobstacle*ipas*latBin, antennaLocation.lng+sobstacle*jpas*lngBloc/pdm);
						d1=L.GeometryUtil.length([antennaLocation, obstacle]);
						d2=L.GeometryUtil.length([point,obstacle]);
						R1=Math.sqrt(0.3*d1*d2/(d1+d2));
						v=hmax*Math.sqrt(2)/R1;
						if(v>1) LKE=-20*Math.log10(0.225/v);
					}
					if(LKE<0) LKE=0.0;
					LFS=32.4+20*Math.log10((d)/1000.0)+20*Math.log10(frequencySpectrum);
					
					Loss=LKE+LFS
					angle=180*Math.atan(Math.abs(hant-hpoint)/d)/Math.PI;
					
					angle=tilt-angle;
					if(angle<0)	angle=360+angle;
					angleindex=Math.floor(angle/5);
					Loss=Loss+ CCost-VertRadiationPattern[angleindex];
					
					if(antennas[a].omni==false){
						if(idist==0 && jdist>0) angle=90;
						else if(idist==0 && jdist<0) angle=270;
						else {
							angle=180*Math.atan(jdist/idist)/Math.PI;
							if(idist<0)
								angle=angle+180;
							if(angle<0) angle=angle+360;
						}
						angle=Math.abs(angle-azimut);
						angleindex=Math.floor(angle/5);
						Loss=Loss-HorzRadiationPattern[angleindex];
					}
				}
				power[a][ipoint][jpoint]=antennas[a].power-Loss;
				
			}
		}
		document.getElementById('cartepower').enabled='';
	}
	function propagationBull() {
		var p1= L.latLng(bloc.lat, bloc.lng);
		var p2= L.latLng(bloc.lat+latBloc, bloc.lng);
		var hautBin=L.GeometryUtil.length([p1, p2])/pdm;
		p1= L.latLng(bloc.lat, bloc.lng);
		p2= L.latLng(bloc.lat, bloc.lng+lngBloc);
		var largBin=L.GeometryUtil.length([p1, p2])/pdm;
		
		qualityThreshold=parseInt(document.getElementById('qualityThreshold').value);
		frequencySpectrum=parseInt(document.getElementById('frequencySpectrum').value);
			
		for(a=0;a<nbantennas;a++){
			antennaLocation=antennas[a].location;
			point=L.latLng(antennaLocation.lat, antennaLocation.lng);
			iant=Math.floor((antennaLocation.lat-southCorner.lat)/latBin);
			jant=Math.floor((antennaLocation.lng-southCorner.lng)/lngBin);
			hant=elevation[iant][jant]+10;
			tilt=antennas[a].tilt;
			if(-200<-iant) iinf=-iant;else iinf=-200;
			if(-200<-jant) jinf=-jant;else jinf=-200;
			if(200>pdm*blockHeight -iant) isup=pdm*blockHeight -iant;else isup=200;
			if(200>pdm*blockWidth -jant) jsup=pdm*blockWidth -jant;else jsup=200;
			for(var jdist=jinf;jdist<=jsup;jdist++)
			for(var idist=iinf;idist<=isup;idist++)
			{
			
				if(idist==0 && jdist==0) continue; 	//si c'est la position de l'antenne alors ignorer
				ipoint=iant+idist;					//coordonnées en maille d'un point de reception	
				jpoint=jant+jdist;
				if(ipoint<0 || jpoint<0 || ipoint >= pdm*blockHeight  || jpoint>=pdm*blockWidth ) continue;
				
				point.lat=antennaLocation.lat+idist*latBin
				point.lng=antennaLocation.lng+jdist*lngBin;
				d=L.GeometryUtil.length([antennaLocation, point]);
				
				
				hpoint=elevation[ipoint][jpoint];
				delta=hant-hpoint-1.5;
			
				alpha;							//l'angle fait entre l'antenne, les latitudes et le point de reception
				if(jdist!=0) {
					alpha=Math.atan(idist/(jdist));
					if(idist<0 && jdist<0)  alpha=alpha+3.14;
					else if(idist>=0 && jdist<0) alpha=alpha+3.14;
				}
				else {
					if(idist>0) alpha=1.5707;
					else alpha=-1.5707;
				}
				jpas=Math.cos(alpha); 			//pas d'avance sur la line directe entre l'antenne et le point de reception
				ipas=Math.sin(alpha);
				distPasBin=Math.sqrt(ipas*ipas*hautBin*hautBin+jpas*jpas*largBin*largBin);
				stotal=Math.floor(d/distPasBin);
				s1=0;
				tangmax=0;
				for(s=1;Math.abs(s*ipas)<Math.abs(idist) && Math.abs(s*jpas)<Math.abs(jdist);s++){	//parcours des obstacle avec un pas ipas, jpas
					dobs=s*distPasBin;
					hv=hant-(dobs/d)*delta;
					hobs=elevation[Math.floor(iant+s*ipas)][Math.floor(jant+s*jpas)]
					if(hobs>hv && ((hobs-hant)/dobs)>tangmax){ 			//si c'est l'obstacle le plus haut 
						tangmax=(hobs-hant)/dobs;
						s1=s;
					}
				}
			
				s2=0;
				tangmax=0;
				for(s=1;Math.abs(s*ipas)<Math.abs(idist);s++){	//parcours des obstacle avec un pas ipas, jpas
					dobs=s*distPasBin;
					hv=hpoint+1.5-(dobs/d)*delta;
					hobs=elevation[Math.floor(ipoint-s*ipas)][Math.floor(jpoint-s*jpas)]
					if(hobs>hv && ((hobs-hpoint)/dobs)>tangmax){ 			//si c'est l'obstacle le plus haut 
						tangmax=(hobs-hpoint)/dobs;
						s2=s;
					}
				}
				var LBull=0.0;
				sobs=0;
				hobs=0;
				if(s1==0 && s2>0) {sobs=stotal-s2;hobs=elevation[Math.floor(ipoint-s2*ipas)][Math.floor(jpoint-s2*jpas)];}
				if(s1>0 && s2==0) {sobs=s1;hobs=elevation[Math.floor(iant+s1*ipas)][Math.floor(jant+s1*jpas)];}
				if(s1>0 && s2>0){
					delta1=(hant-elevation[Math.floor(iant+s1*ipas)][Math.floor(jant+s1*jpas)]);
					delta2=(hpoint+1.5-elevation[Math.floor(ipoint-s2*ipas)][Math.floor(jpoint-s2*jpas)]);
					d1=s1*distPasBin;
					d2=s2*distPasBin;
					s3=stotal-s2;
					min=1000.0;
					for(s=s1;s<=s3;s++){
						dobs1=s*distPasBin;
						dobs2=(stotal-s)*distPasBin;
						if(Math.abs((hpoint+1.5-delta2*dobs2/d2)-(hant-delta1*dobs1/d1))<min){
							min= Math.abs((hpoint+1.5-delta2*dobs2/d2)-(hant-delta1*dobs1/d1));
							sobs=s;
							hobs=hpoint+1.5-delta2*dobs2/d2;
						}
					}
				}
				if(s1==0 && s2==0) LBull=0.0;
				else{
					obstacle=new google.maps.LatLng(antennaLocation.lat+sobs*ipas*latBin, antennaLocation.lng+sobs*jpas*lngBin);
					d1=google.maps.geometry.spherical.computeDistanceBetween(antennaLocation,obstacle);
					d2=google.maps.geometry.spherical.computeDistanceBetween(point,obstacle);
					R1=Math.sqrt(0.3*d1*d2/(d1+d2));
					hv=hant-(d1/(d1+d2))*delta;
					v=(hobs-hv)*Math.sqrt(2)/R1;
					if(v>1) LBull=-20*Math.log10(0.225/v);
				}
				if(LBull<0){
					if(LBull<0) LBull=0.0;
				}
				LFS=32.4+20*Math.log10((d)/1000.0)+20*Math.log10(frequencySpectrum);
			
				L=LFS+LBull
				angle=180*Math.atan(Math.abs(hant-hpoint)/d)/Math.PI;
					
				angle=tilt-angle;
				if(angle<0)	angle=360+angle;
				angleindex=Math.floor(angle/5);
				L=L+ CCost-VertRadiationPattern[angleindex];
				
				if(antennas[a].omni==false){
						if(idist==0 && jdist>0) angle=90;
						else if(idist==0 && jdist<0) angle=270;
						else {
							angle=180*Math.atan(jdist/idist)/Math.PI;
							if(idist<0)
								angle=angle+180;
							if(angle<0) angle=angle+360;
						}
						angle=Math.abs(angle-azimut);
						angleindex=Math.floor(angle/5);
						L=L-HorzRadiationPattern[angleindex];
					}
				
				power[a][ipoint][jpoint]=antennas[a].power-L;
			}
		}
		document.getElementById('cartepower').enabled='';
	}

	function propagationFreeSpace(){
		for(a=0;a<nbantennas;a++){
			antennaLocation=antennas[a].location;
			point=L.latLng(antennaLocation.lat, antennaLocation.lng);
			iant=Math.floor((antennaLocation.lat-southCorner.lat)/latBin);
			jant=Math.floor((antennaLocation.lng-southCorner.lng)/lngBin);
			if(-200<-iant) iinf=-iant;else iinf=-200;
			if(-200<-jant) jinf=-jant;else jinf=-200;
			if(200>pdm*blockHeight -iant) isup=pdm*blockHeight -iant;else isup=200;
			if(200>pdm*blockWidth -jant) jsup=pdm*blockWidth -jant;else jsup=200;
			for(var jdist=jinf;jdist<=jsup;jdist++)
			for(var idist=iinf;idist<=isup;idist++)
			{
				ipoint=iant+idist;					//coordonnées en maille d'un point de reception	
				jpoint=jant+jdist;	
				if(ipoint<0 || jpoint<0 || ipoint >= pdm*blockHeight  || jpoint>=pdm*blockWidth ) continue;
				point.lat=antennaLocation.lat+idist*latBin
				point.lng=antennaLocation.lng+jdist*lngBin;
				d=L.GeometryUtil.length([antennaLocation, point]);
				if(idist==0 && jdist==0) { 	//si c'est la position de l'antenne alors ignorer
					Loss=0;
				}
				else{
					Loss=32.44 + 20*Math.log(parseInt(document.getElementById('frequencySpectrum').value)) + 20*Math.log(d);
				}
			
				power[a][ipoint][jpoint] = antennas[a].power + parseInt(document.getElementById('gainUE').value) + parseInt(document.getElementById('inputAntennaGain').value) - Loss + 100;
			}
		}
		document.getElementById('cartepower').enabled='';
	}
	
	function vider() {
		while(bins.length){
				bins.pop().remove();
		}
	}
		
	function batiment(){
		document.getElementById('message').value="Positionner le 1er coin du batiment";
		modeclick=3;
		
		document.getElementById('cartepower').disabled='disabled';
		document.getElementById('carteinterference').disabled='disabled';
		document.getElementById('cartehandover').disabled='disabled';
		document.getElementById('cartecellule').disabled='disabled';
		document.getElementById('carteresidence').disabled='disabled';
	}
	var batiments=[];
	var axes=[];
	var hautsBat=[];
	var coinsBat=[];
	function placeBat(location){
		coinsBat.push(location);
	}
	function placeBat2(location){
		coinsBat.push(location);
		bat = L.polygon(coinsBat,
					{fillColor: 'grey',
						fillOpacity: 1,
						color : 'transparent'}).addTo(mymap);
		batiments.push(bat);
		bat.on('dblclick', function(event) {
			rep=confirm("voulez vous supprimer le batiment");
			if(rep==true) {
							index=batiments.indexOf(this);
				for(i=0;i<pdm*blockHeight ;i++){
					for(j=0;j<blockWidth *pdm;j++){
						point=L.latLng(southCorner.lat+i*latBin, southCorner.lng+j*lngBin);
						if(this.getBounds().contains(point))
						{architecture[i][j]=0;}
					}
				}
				batiments.splice(index, 1);
				hautsBat.splice(index,1);
				this.remove();
			}
		});
		bat.on('contextmenu', function(event) {
			index=batiments.indexOf(this);
			rep=alert("Hauteur du batiment : "+hautsBat[index]+ " metres");
		});
		coinsBat=[];
		
		h=parseInt(prompt("Enter the height of the building in meters", "10"));

		for(i=0;i<pdm*blockHeight ;i++){
			for(j=0;j<blockWidth *pdm;j++){
				point=L.latLng(southCorner.lat+i*latBin, southCorner.lng+j*lngBin);
				if(bat.getBounds().contains(point))
				{
					architecture[i][j]=h;
				}
			}
		}
		hautsBat.push(h);
		document.getElementById('message').value="choisissez une action !";
	}

	function addAntennaConstructor(){
		document.getElementById('message').value="Positionnez l'antenne ! ou Escap pour annuler !";
		frameantenna.style.display="block";
		antennaListUE.style.display="none";
		document.getElementById('omni').checked=true;
		modeclick=1;
		
		document.getElementById('propag').disable='disabled';
		document.getElementById('cartepower').disabled='disabled';
		document.getElementById('carteinterference').disabled='disabled';
		document.getElementById('cartehandover').disabled='disabled';
		document.getElementById('cartecellule').disabled='disabled';
		document.getElementById('carteresidence').disabled='disabled';
	}

	function addUEConstructor(){
		frameantenna.style.display="none";
		antennaListUE.style.display="block";
		console.log("click UE");
		modeclick = 4;
		document.getElementById('message').value="Select your start and arrival point";
	}

	
	function cartecellule(){
		vider();
		qualityThreshold=parseInt(document.getElementById('qualityThreshold').value);
		southCornerlat=southCorner.lat;
		southCornerlng=southCorner.lng;
		var a=0;
		for(i=0;i<blockHeight *pdm;i++){
			for(j=0;j<blockWidth *pdm;j++){
				max=-1000;
				bestant=-1;
				for(a=0;a<nbantennas;a++){
					if(power[a][i][j]>max) {max=power[a][i][j];	bestant=a;}
				}
				if(max<qualityThreshold) continue;
				plat=southCornerlat+i*latBin;
				plng=southCornerlng+j*lngBin;
				
				r=(bestant*82)%213;
				v=(bestant*17)%207;
				b=(bestant*87)%107+107;
				if(r<16)strred="0"+r.toString(16); else strred=r.toString(16);
				if(b<16)strblue="0"+b.toString(16); else strblue=b.toString(16);
				if(v<16)strgreen="0"+v.toString(16); else strgreen=v.toString(16);
				couleur="#"+strred+strgreen+strblue;
				
				var bin = L.polygon([
					[plat, plng],
					[plat+latBin, plng],
					[plat+latBin, plng+lngBin],
					[plat, plng+lngBin]
					],{fillColor: couleur,
						fillOpacity: 1,
						color : 'transparent'}).addTo(mymap);
				bins.push(bin);
			}
		}
	}
	function choixenv(){
		m=document.getElementById('methode').value;
		if(m==8){
			rep=confirm("Est un environnement urbain ?");
			if(rep==true)
				CCost=3;
			else CCost=0;
		}
		document.getElementById('propag').disable='disabled';
		document.getElementById('cartepower').disabled='disabled';
		document.getElementById('carteinterference').disabled='disabled';
		document.getElementById('cartehandover').disabled='disabled';
		document.getElementById('cartecellule').disabled='disabled';
		document.getElementById('carteresidence').disabled='disabled';
	}
	function choixcarto(){
		rep=confirm("Transparent pour les zones hors qualityThresholds ?");
		if(rep==true)
			carto=true;
		else carto=false;
	}
	function cartepower(){
		vider();
		qualityThreshold=parseInt(document.getElementById('qualityThreshold').value);
		southCornerlat=southCorner.lat;
		southCornerlng=southCorner.lng;
		for(i=0;i<blockHeight *pdm;i++){
			for(j=0;j<blockWidth *pdm;j++){
				max=-1000;
				for(var a=0;a<nbantennas;a++){
					if(power[a][i][j]>max) max=power[a][i][j];
				}
				if(max<qualityThreshold) continue;
				plat=southCornerlat+i*latBin;
				plng=southCornerlng+j*lngBin;
				couleur=GetColor(Math.floor(max));
				var bin = L.polygon([
					[plat, plng],
					[plat+latBin, plng],
					[plat+latBin, plng+lngBin],
					[plat, plng+lngBin]
					],{fillColor: couleur,
						fillOpacity: 1,
						weight: 0,
						color : 'none'}).addTo(mymap);
				bins.push(bin);
			}
		}
	}
	function carteinterference(){
		vider();
		qualityThreshold=parseInt(document.getElementById('qualityThreshold').value);
		for(i=0;i<blockHeight *pdm;i++){
			for(j=0;j<blockWidth *pdm;j++){
				max=-1;
				suminterf=Math.pow(10,-15);
				for(var a=0;a<nbantennas;a++){
					if(Math.pow(10,power[a][i][j]/10.0)>max) {
						if(max!=-1)	suminterf+=max;
						max=Math.pow(10,power[a][i][j]/10.0);
					}
					else suminterf+=Math.pow(10,power[a][i][j]/10.0);
				}
				CIR=max/suminterf;
				if(CIR>1.5) continue;
				else if(CIR>1) {r=1;v=69;b=250;}
				else if(CIR>0.5){r=1;v=250;b=57;}
				else if(CIR>0.33){r=188;v=251;b=0;}
				else if(CIR>0.25){r=244;v=251;b=0;}
				else if(CIR>0.20){r=251;v=220;b=0;}
				else {r=250;v=123;b=0;}
		
				if(r<16)strred="0"+r.toString(16); else strred=r.toString(16);
				if(b<16)strblue="0"+b.toString(16); else strblue=b.toString(16);
				if(v<16)strgreen="0"+v.toString(16); else strgreen=v.toString(16);
				couleur="#"+strred+strgreen+strblue;
				
				plat=southCorner.lat+i*latBin;
				plng=southCorner.lng+j*lngBin;
				
				var bin = L.polygon([
					[plat, plng],
					[plat+latBin, plng],
					[plat+latBin, plng+lngBin],
					[plat, plng+lngBin]
					],{fillColor: couleur,
						fillOpacity: 1,
						color : 'transparent'}).addTo(mymap);
				bins.push(bin);
			}
		}
	}

	function set3ClosestAntennas(uePosition){

		
		if(antennas.length >= 1){
			document.getElementById('labelAntenna1Type').innerHTML="Antenna type : " ;
			document.getElementById('labelAntenna1Freq').innerHTML="Antenna frequency : ";
			document.getElementById('labelAntenna1Pow').innerHTML="Antenna power : " + antennas[0].power + "dB?";
		}
		if(antennas.length >= 2){
			document.getElementById('labelAntenna2Type').innerHTML="Antenna type : ";
			document.getElementById('labelAntenna2Freq').innerHTML="Antenna frequency : ";
			document.getElementById('labelAntenna2Pow').innerHTML="Antenna power : " + antennas[1].power + "dB?";
		}
		if(antennas.length >= 3){
			document.getElementById('labelAntenna3Type').innerHTML="Antenna type : ";
			document.getElementById('labelAntenna3Freq').innerHTML="Antenna frequency : ";
			document.getElementById('labelAntenna3Pow').innerHTML="Antenna power : " + antennas[2].power + "dB?";
		}
		console.log("antennas.length : " + antennas.length); 

	}

	function setUEAntenna(location){
		// First selection of antenna
		if(antennas.length < 1) return;

		if(selectedAntennaCircle != undefined)
			mymap.removeLayer(selectedAntennaCircle);
		
		var power_received=-200;
		var selected_antenna_index=-1;
		var tmp = 0;

		// selection of the antenna in function of the received power from each antenna
		point=L.latLng(uePosition.lat,uePosition.lng);
		iue=Math.floor((uePosition.lat-southCorner.lat)/latBin);
		jue=Math.floor((uePosition.lng-southCorner.lng)/lngBin);if(-200<-iant) iinf=-iant;else iinf=-200;
		for(var i = 0;i < antennas.length; i++){
			tmp = power[i][iue][jue];
			if (tmp > power_received && tmp > -140){
				power_received = tmp;
				selected_antenna_index = i;
			}
			tmp = 0;
		}
		
		if(selected_antenna_index >= 0){
			selectedAntennaCircle = L.circle([antennas[selected_antenna_index].location.lat, antennas[selected_antenna_index].location.lng], {
					color: 'green', // the chosen antenna will be green on the map
					fillColor: '#f03',
					fillOpacity: 0.5,
					radius: 10
					}).addTo(mymap);
		}
		document.getElementById('receivedPower').value = power_received;
	}

	function setUE(location){
		if(markerIcon != undefined)
			mymap.removeLayer(markerIcon);
		var myIcon = L.icon({
		    iconUrl: 'pedestrian.gif',
		    iconSize: [24,30],
			iconAnchor: [12, 30],
		});
		markerIcon = L.marker([uePosition.lat, uePosition.lng],
		{
			icon: myIcon
		}).addTo(mymap);
	}

	function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {
	  var R = 6371; // Radius of the earth in km
	  var dLat = deg2rad(lat2-lat1);  // deg2rad below
	  var dLon = deg2rad(lon2-lon1); 
	  var a = 
	    Math.sin(dLat/2) * Math.sin(dLat/2) +
	    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
	    Math.sin(dLon/2) * Math.sin(dLon/2)
	    ; 
	  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
	  var d = R * c; // Distance in km
	  return d;
	}

	function deg2rad(deg) {
	  return deg * (Math.PI/180)
	}

	/*function sortAntennasUE(uePosition){
		antennas.sort((a,b) => (
			getDistanceFromLatLonInKm(a.location.lat,a.location.lng,uePosition.lat,uePosition.lng) 
			> 
			getDistanceFromLatLonInKm(b.location.lat,b.location.lng,uePosition.lat,uePosition.lng) 
		) ? 1 : -1);
	}*/

	function onMapClick(e) {
		//alert("You clicked the map at " + e.latlng);
		if(modeclick==0) {modeclick=2;placeCorner(e.latlng);}
		else if(modeclick==1) {modeclick=2;placeAntennaConstructor(e.latlng,0);}
		else if(modeclick==3) {placeBat(e.latlng);}
		else if(modeclick==4) {placeUE(e.latlng);}
		else if(modeclick==5) {placeArrival(e.latlng);}
	}
	function onMapDbClick(e) {
		if(modeclick==3) {modeclick=2;placeBat2(e.latlng);}
	} 
	function mainLoop(){
		if(uePosition == undefined){
			alert("You have not selected a UE path");
			return
		}
		if(toggle == 0){
			console.log("Start");
			toggle = 1;
			coefPath = (ueArrival.lat - ueStart.lat) / (ueArrival.lng - ueStart.lng); // coef of the affine func (representing the UE path)
			intervalID = setInterval(function(){loop();}, 200);
		}else if(toggle == 1){
			console.log("Stop");
			toggle = 0;
			clearInterval(intervalID);
		}
	}

	function loop(){
		var step = 1;
		var aSecDeg = uePosition.lng * uePosition.lng + 1; 
		var bSecDeg = -2 * uePosition.lng -2 * coefPathA * uePosition.lat; 
		var cSecDeg = uePosition.lng * uePosition.lng + uePosition.lat * uePosition.lat - step;
		var x2 = (bSecDeg + Math.sqrt(bSecDeg*bSecDeg - 4*aSecDeg*cSecDeg)) / (2*aSecDeg); 
		var y2 = coefPathA * x2 + coefPathB;

		console.log("aSecDeg : " + aSecDeg);
		console.log("bSecDeg : " + bSecDeg);
		console.log("cSecDeg : " + cSecDeg);


		console.log("x2+ : " + x2);
		console.log("y2+ : " + y2);

		x2 = (bSecDeg - Math.sqrt(bSecDeg*bSecDeg - 4*aSecDeg*cSecDeg)) / (2*aSecDeg); 
		y2 = coefPathA * x2 + coefPathB;
		console.log("x2- : " + x2);
		console.log("y2- : " + y2);


		if((ueArrival.lat-uePosition.lat) > 0.0001)
			uePosition.lat += 0.0001;
		else if ((ueArrival.lat-uePosition.lat) < -0.0001)
			uePosition.lat -= 0.0001;

		if((ueArrival.lng-uePosition.lng)>0.0001)
			uePosition.lng += 0.0001;
		else if ((ueArrival.lng-uePosition.lng) < -0.0001)
			uePosition.lng -= 0.0001;

		if( ((ueArrival.lng-uePosition.lng) < 0.0001) && ((ueArrival.lng-uePosition.lng) > -0.0001) &&
			((ueArrival.lat-uePosition.lat) < 0.0001) && ((ueArrival.lat-uePosition.lat) > -0.0001)){
			alert("You arrived");
			toggle = 0;
			clearInterval(intervalID);
		}

		//sortAntennasUE(uePosition);
		set3ClosestAntennas(uePosition);
		setUEAntenna(uePosition);
		setUE(uePosition);
		console.log("New position : " + uePosition);
		// sleep(500);
	}

	function sleep(milliseconds) {
	  const date = Date.now();
	  let currentDate = null;
	  do {
	    currentDate = Date.now();
	  } while (currentDate - date < milliseconds);
	}

	</script>
</head>
  <body>
	<div id="conteneur">
		<div id="header">
			<div> <input type="text" style="width:400px;" id="message" value="Sélectionnez le coin inférieur gauche de la zone d'étude !" readonly> </div>
		</div>
		<div id="sidebar">
			<div><label id="labeltech">Technologie radio : </label></div>
			<select name="Combobox1" size="1" id="techno" style="width: 98%;">
				<option value="1">GSM</option>
				<option selected value="2">UMTS</option>
				<option value="3">LTE</option>
				<option value="4">TDF</option>
				<option value="5">HSDPA</option>
				<option value="6">WiMAX</option>
			</select>
			<div><label id="labelfrequencySpectrum"  style="width: 50%;">Bande(Mhz) : </label><input type="number" id="frequencySpectrum" name="frequencySpectrum" value="1800" align="right" style="width: 50%;"></div>
			<div><label id="labelqualityThreshold" style="width: 50%;">Seuil (Db) : </label><input type="number" id="qualityThreshold" name="qualityThreshold" value="-140" style="width: 50%;"></div>
			<div> <label id="labelblockHeight " style="width: 30%;">Hauteur de la zone (200m) : </label><input type="number" id="blockHeight " name="blockHeight " value="10" style="width: 20%;"></div>
			<div> <label id="labelblockWidth " style="width: 30%;">Largeur de la zone (200m) : </label><input type="number" id="blockWidth " name="blockWidth " value="10" style="width: 20%;"></div>
			<div><label id="labelmodele">Modèle de propagation : </label></div>
		  <select name="Combobox1" size="1" id="methode" style="width: 98%;" onchange="choixenv()">
			<option value="1">Single Knife Edge (rural)</option>
			<option value="2">Bullington (rural)</option>
			<option value="3">Epstein Method</option>
			<option value="4">Deygout (rural)</option>
			<option value="5">Causebrook</option>
			<option value="6">Okumura</option>
			<option value="7">Okumura-Hata</option>
			<option value="8">COST231-Hata (rural,urban)</option>
			<option value="9">Walfisch-Ikegami(urban)</option>
			<option value="10">Stanford University Interim</option>
			<option selected value="11">Free Space</option>
		  </select>
		  <div> <input type="button" id="cartepower" value="Cartographie de power" onclick="cartepower()" disabled='disabled' style="width: 98%;"/></div>
		  <div> <input type="button" id="carteinterference" value="Cartographie des C/I" onclick="carteinterference()" disabled='disabled' style="width: 98%;"/></div>
		  <div> <input type="button" id="cartehandover" value="Cartographie de handover" onclick="cartehandover()" disabled='disabled' style="width: 98%;"/></div>
		  <div> <input type="button" id="cartecellule" value="Cartographie des cellules" onclick="cartecellule()" disabled='disabled' style="width: 98%;"/></div>
		  <div> <input type="button" id="carteresidence" value="Temps de résidance" onclick="carteresidence()" disabled='disabled' style="width: 98%;"/></div>
		  <div id="frameantenna">
				<label id="labomni">Omni : </label>
				<input type="radio" name="omni" id="omni" value="omni" />
				<label id="labsect">Sectorielle : </label>
				<input type="radio" name="omni" id="sect" value="sectorial" />
				<div><label id="labelpower">Puissance rayonnée: </label></div>
				<div> <input type="number" id="power" name="power" value="30" style="width: 98%;"></div>
				<div><label id="antennaGain">Antenna Gain(dBm) : </label></div>
				<div> <input type="number" id="inputAntennaGain" name="inputAntennaGain" value="20" style="width: 98%;"></div>
				<div><label id="labeltilt">Tilt : </label></div>
				<div> <input type="number" id="tilt" name="tilt" value="30" style="width: 98%;"></div>
				<div><label id="labelazimut">Azimut : </label></div>
				<div> <input type="number" id="azimut" name="azimut" value="0" style="width: 98%;"></div>
				<div><label id="freq1">Fréquence 1 : </label></div>
				<div> <input type="number" id="frequence1" name="frequence1" style="width: 98%;"></div>
				<div><label id="freq1">Fréquence 2 : </label></div>
				<div> <input type="number" id="frequence2" name="frequence2" style="width: 98%;"></div>
				<div><label id="freq1">Fréquence 3 : </label></div>
				<div> <input type="number" id="frequence3" name="frequence3" style="width: 98%;"></div>
				<div><label id="freq1">Fréquence 4 : </label></div>
				<div> <input type="number" id="frequence4" name="frequence4" style="width: 98%;"></div>
		  </div>


		 	<div id="antennaListUE" style = "display:none;">
				<div><label id="labelUE">User Equipment <br></label></div>
			 	<div> <label id="labelAntennaCo" style="width: 30%;">Antenna connected : </label><input type="text" id="antennaCo" name="antennaCo" value="None" style="width: 30%;" disabled=""></div>
			 	<div> <label id="labelReceivedPower" style="width: 30%;">Received power : </label><input type="number" id="receivedPower" name="receivedPower" value="0" style="width: 30%;" disabled=""></div>
			 	<div> <label id="labelGainUE" style="width: 30%;">UE Gain(dBm) : </label><input type="number" id="gainUE" name="gainUE" value="15" style="width: 30%;"></div>
		 		<div><br><label id="antenna1">Antenna 1 : <br></label></div>
			 	<div> <label id="labelAntenna1Type" style="width: 30%;">Antenna type : </label></div>
			 	<div> <label id="labelAntenna1Freq" style="width: 30%;">Antenna frequency : </label></div>
			 	<div> <label id="labelAntenna1Pow" style="width: 30%;">Antenna power : </label></div>

		 		<div><br><label id="antenna2">Antenna 2 : <br></label></div>
			 	<div> <label id="labelAntenna2Type" style="width: 30%;">Antenna type : </label></div>
			 	<div> <label id="labelAntenna2Freq" style="width: 30%;">Antenna frequency : </label></div>
			 	<div> <label id="labelAntenna2Pow" style="width: 30%;">Antenna power : </label></div>

		 		<div><br><label id="antenna3">Antenna 3 : <br></label></div>
			 	<div> <label id="labelAntenna3Type" style="width: 30%;">Antenna type : </label></div>
			 	<div> <label id="labelAntenna3Freq" style="width: 30%;">Antenna frequency : </label></div>
			 	<div> <label id="labelAntenna3Pow" style="width: 30%;">Antenna power : </label></div>
			 	
		 	</div>
			
		</div>
		<div id="contenu">
			
			<div id="mapid"></div>
		</div>
		<div id="footer">
			<div>
		  <button type="button" id="propag" value="Propagation" onclick="propagation()" disabled='disabled'> <img src="propag.png"> </button>
		  <button type="button" id="remove" value="Effacer" onclick="vider()"> <img src="effacer.png"> </button>
		  <button type="button" id="routes" value="Extraire les routes de la zone (0,0)" onclick="routes()" disabled='disabled'><img src="routes.png"> </button>
		  <button type="button" id="completer" value="Compléter les routes" onclick="completer()" disabled='disabled'><img src="routes+.png"> </button>
		  <button type="button" id="axes" value="Ajouter un axe routier" onclick="addaxe()" disabled='disabled'><img src="routes.png"> </button>
		  <button type="button" id="batiment" value="Ajouter un bâtiment" onclick="batiment()" disabled='disabled'><img src="bat.png"> </button>
		  <button type="button" id="saveBat" value="Enregister les bâtiments" onclick="saveNet()" disabled='disabled'><img src="saveNet.png"> </button>
		  <button type="button" id="loadBat" value="Charger les bâtiments" onclick="loadNet()" disabled='disabled'><img src="loadNet.png"> </button>
		  <button type="button" id="antenne" value="Ajouter une antenne" onclick="addAntennaConstructor()" disabled='disabled'><img src="antenna.png"> </button>
		  <button type="button" id="ecole" value="Ajouter une zone sensible" onclick="addEcole()" disabled='disabled'><img src="ecole.png"> </button>
		  <button type="button" id="ue" value="Add a User Equipment" onclick="addUEConstructor()" disabled='disabled'><img src="userEquipment.png"> </button>
		  <button type="button" id="startSim" value="Start simu" onclick="mainLoop()" disabled='disabled'><img src="playButton.png"> </button>
		  <input type="file" id="fileinput" />
		  </div>
		</div>
	</div>
  </body>
<!-- <script src="leaflet-geotiff.js"></script> -->
  <script> 

var mymap = L.map('mapid').setView([45.76150744149685, 4.83237850949616], 13);


	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	}).addTo(mymap);


mymap.on('click', onMapClick);
mymap.on('dblclick', onMapDbClick);
frameantenna=document.getElementById('frameantenna'); 
frameantenna.style.display='none';
</script>
</html>